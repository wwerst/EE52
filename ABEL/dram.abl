MODULE DRAM

TITLE 'DRAM Interface - State Machine Version'

" DRAM Interface  EE52 Project


" Description:  Controls DRAM access


" Revision History:
" Will Werst   3/12/2017   Wrote code



" Pins


"      pin   1                   input   unused
"      pin   2                   input   unused
"      pin   3                   input   unused
"      pin   4                   input   unused
"      pin   5                   input   unused
"      pin   6                   input   unused
"      pin   7                   input   unused
"      pin   8                   input   unused
"      pin   9                   input   unused
"      pin   10                  input   unused
"      pin   11                  input   unused
"      pin   12                  input   unused
"      pin   13                  input   unused
"      pin   14                  input   unused
!JTAG_NTRST pin   15;           "JTAG NTRST input
!NReset pin  16;                "Reset input
!NTRST pin   17  ISTYPE 'com';  "TRST output  
RAS    pin   18  ISTYPE 'com';  "RAS line
CAS    pin   19  ISTYPE 'com';  "CAS line
!DRAM_WE pin  20  ISTYPE 'com';  "Write Enable Line to DRAM
!R_A_EN pin   21 ISTYPE 'com';  "Buffer row address enable
!C_A_EN pin   22 ISTYPE 'com';  "Buffer column address enable line
"      pin   23                  input   unused
"      pin   24                  input   unused
!NCS   pin   25;                "input chip select
!NWE   pin   26;                "input for whether write access
!NWAIT pin   27  ISTYPE 'com';  "output for making cpu wait for refresh finish
!MCLK   pin   28;                "main clock input
!RCLK   pin   29;                "refresh clock input
"      pin   13                  output  unused
"      pin   14                  output  unused
"      pin   15                  output  unused
"      pin   16                  output  unused
St0    pin 37      ISTYPE 'reg';  "output  state bit 0
St1    pin 38      ISTYPE 'reg';  "output  state bit 1
St2    pin 39      ISTYPE 'reg';  "output  state bit 2
St3    pin 40      ISTYPE 'reg';  "output  state bit 3
St4    pin 41      ISTYPE 'reg';  "output  state bit 4
RefRqst pin      ISTYPE 'reg';  "refresh request bit
RefInProgress pin	ISTYPE	'reg_SR';	"bit indicating refresh just finished, used to implement logic for holding nwait one more cycle
RefInProgressDelay pin	ISTYPE	'reg_D';
"      pin   17                  output  unused
"      pin   18                  output  unused



"the states

StateBits   =  [ St4, St3, St2, St1, St0 ];     " state bits
                                      		" state assignments
Idle        =  [   0,   0,   0,   0,   0 ];     " idle state (waiting for a cycle to start)
Read0       =  [   0,   0,   0,   0,   1 ];     " enable row address for read
Read1       =  [   0,   0,   0,   1,   0 ];     " RAS line low
Read2       =  [   0,   0,   0,   1,   1 ];     " disable row address for read
Read3       =  [   0,   0,   1,   0,   0 ];     " enable column address for read
Read4       =  [   0,   0,   1,   0,   1 ];     " CAS line low
Read5       =  [   0,   0,   1,   1,   0 ];     " Wait for data access
Read6       =  [   0,   0,   1,   1,   1 ];     " CAS line high
Read7       =  [   0,   1,   0,   0,   0 ];     " Pre-charge
Read8       =  [   0,   1,   0,   0,   1 ];     " Pre-charge
Write0      =  [   0,   1,   0,   1,   0 ];     " enable row address
Write1      =  [   0,   1,   0,   1,   1 ];     " RAS line low
Write2      =  [   0,   1,   1,   0,   0 ];     " disable row address
Write3      =  [   0,   1,   1,   0,   1 ];     " WE low and column address enable
Write4      =  [   0,   1,   1,   1,   0 ];     " CAS line low
Write5      =  [   0,   1,   1,   1,   1 ];     " Wait
Write6      =  [   1,   0,   0,   0,   0 ];     " RAS, CAS, WE high
Write7      =  [   1,   0,   0,   0,   1 ];     " Pre-charge
Write8      =  [   1,   0,   0,   1,   0 ];     " Pre-charge
Ref0        =  [   1,   0,   0,   1,   1 ];     " CAS low
Ref1        =  [   1,   0,   1,   0,   0 ];     " RAS low
Ref2        =  [   1,   0,   1,   0,   1 ];     " Wait
Ref3        =  [   1,   0,   1,   1,   0 ];     " Wait
Ref4        =  [   1,   0,   1,   1,   1 ];     " Wait
Ref5        =  [   1,   1,   0,   0,   0 ];     " RAS, CAS high
Ref6        =  [   1,   1,   0,   0,   1 ];     " Pre-charge
Ref7        =  [   1,   1,   0,   1,   0 ];     " Pre-charge
Inval0      =  [   1,   1,   0,   1,   1 ];     " Invalid state
Inval1      =  [   1,   1,   1,   0,   0 ];     " Invalid state
Inval2      =  [   1,   1,   1,   0,   1 ];     " Invalid state
Inval3      =  [   1,   1,   1,   1,   0 ];     " Invalid state
Inval4      =  [   1,   1,   1,   1,   1 ];     " Invalid state


EQUATIONS


" NWAIT equation
NWAIT = ((RefInProgress # RefInProgressDelay));


NTRST = NReset & JTAG_NTRST;
DRAM_WE = NWE & NCS;


" clocks for the registered outputs (state bits)
StateBits.CLK  =  MCLK;        " use the global clock pin
"NWAIT.CLK = MCLK;

RefInProgress.S = (StateBits == Ref0);
RefInProgress.R = (StateBits == Idle);
RefInProgress.CLK = MCLK;
RefInProgressDelay.D = RefInProgress;
RefInProgressDelay.CLK = MCLK;
RefRqst.CLK = RCLK;
RefRqst.AR = (StateBits == Ref7);
RefRqst := 1;

STATE_DIAGRAM  StateBits        " a Mealy state machine


STATE  Idle:                    " in the idle state waiting for an access

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN Idle;
   ELSE IF (RefRqst) THEN  Ref0;
   "ELSE IF (NCS & NWE) THEN Write0;
   ELSE IF (NCS) THEN      Read0;
   ELSE                       Idle;     " otherwise just stay here

STATE Read0:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 1;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Read1;

STATE Read1:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 1;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Read2;

STATE Read2:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Read3;

STATE Read3:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 1;

   IF (NReset) THEN        Idle;
   ELSE                   Read4;

STATE Read4:

   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 1;

   IF (NReset) THEN        Idle;
   ELSE                   Read5;

STATE Read5:

   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 1;
   
   IF (NReset) THEN        Idle;
   ELSE                   Read6;


STATE Read6:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Read7;

STATE Read7:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Read8;


STATE Read8:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO Idle;


STATE Write0:
   
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 1;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Write1;

STATE Write1:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 1;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Write2;

STATE Write2:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Write3;

STATE Write3:

   RAS = 0;
   CAS = 1;
   "DRAM_WE = 0;
   R_A_EN = 0;
   C_A_EN = 1;

   IF (NReset) THEN        Idle;
   ELSE                   Write4;

STATE Write4:

   RAS = 0;
   CAS = 0;
   "DRAM_WE = 0;
   R_A_EN = 0;
   C_A_EN = 1;

   IF (NReset) THEN        Idle;
   ELSE                   Write5;

STATE Write5:
   
   RAS = 0;
   CAS = 0;
   "DRAM_WE = 0;
   R_A_EN = 0;
   C_A_EN = 1;

   IF (NReset) THEN        Idle;
   ELSE                   Write6;


STATE Write6:


   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Write7;

STATE Write7:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Write8;


STATE Write8:

   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO Idle;

STATE Ref0:
   
   RAS = 1;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Ref1;

STATE Ref1:

   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Ref2;


STATE Ref2:
   
   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (NReset) THEN        Idle;
   ELSE                   Ref3;

STATE Ref3:
   
   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;


   IF (NReset) THEN        Idle;
   ELSE                   Ref4;


STATE Ref4:
   
   RAS = 0;
   CAS = 0;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;


   IF (NReset) THEN        Idle;
   ELSE                   Ref5;


STATE Ref5:

   
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;


   IF (NReset) THEN        Idle;
   ELSE                   Ref6;

STATE Ref6:

   
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;


   IF (NReset) THEN        Idle;
   ELSE                   Ref7;

STATE Ref7:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;

STATE Inval0:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;

STATE Inval1:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;

STATE Inval2:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;

STATE Inval3:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;

STATE Inval4:
   RAS = 1;
   CAS = 1;
   "DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   GOTO                   Idle;




TEST_VECTORS

( [  MCLK,  RCLK, NReset,  NCS,  NWE ] -> [   RAS, CAS, DRAM_WE, R_A_EN, C_A_EN, NWAIT, RefRqst, St0, St1, St2, St3, St4 ] )

  [     0,     0,      0,    0,   0  ] -> [   .X., .X.,     .X.,    .X.,    .X.,   .X.,     .X., .X., .X.,  .X., .X., .X. ];


" reset the system
  [   .C.,     0,      1,    1,   1  ] -> [     1,   1,       1,      0,      0,     0,     .X., .X., .X.,  .X., .X., .X. ];
  [   .C.,     0,      1,    1,   1  ] -> [     1,   1,       1,      0,      0,     0,     .X., .X., .X.,  .X., .X., .X. ];
  [   .C.,     0,      1,    1,   1  ] -> [     1,   1,       1,      0,      0,     0,     .X., .X., .X.,  .X., .X., .X. ];

" Single read
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read0
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read1
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read2
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read3
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read4
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read5
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read6
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0,   0,   0,    0,   0,   0 ]; "Idle

" Single write
  [   .C.,     0,      0,    1,   1  ] -> [     1,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write0
  [   .C.,     0,      0,    1,   1  ] -> [     0,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write1
  [   .C.,     0,      0,    1,   1  ] -> [     0,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write2
  [   .C.,     0,      0,    1,   1  ] -> [     0,   1,       0,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write3
  [   .C.,     0,      0,    1,   1  ] -> [     0,   0,       0,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write4
  [   .C.,     0,      0,    1,   1  ] -> [     0,   0,       0,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write5
  [   .C.,     0,      0,    1,   1  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Write6
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0,   0,   0,    0,   0,   0 ]; "Idle

" Consecutive reads
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read0
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read1
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read2
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read3
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read4
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read5
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read6
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0,   0,   0,    0,   0,   0 ]; "Idle
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read0
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      1,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read1
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read2
  [   .C.,     0,      0,    1,   0  ] -> [     0,   1,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read3
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read4
  [   .C.,     0,      0,    1,   0  ] -> [     0,   0,       1,      0,      1,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read5
  [   .C.,     0,      0,    1,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Read6
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Pre-charge
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0,   0,   0,    0,   0,   0 ]; "Idle

" Refresh
  [     0,   .C.,      0,    0,   0  ] -> [   .X., .X.,     .X.,    .X.,    .X.,   .X.,       1, .X., .X.,  .X., .X., .X. ]; "Trigger the refresh request
  [   .C.,     0,      0,    0,   0  ] -> [     1,   0,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref0
  [   .C.,     0,      0,    0,   0  ] -> [     0,   0,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref1
  [   .C.,     0,      0,    0,   0  ] -> [     0,   0,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref2
  [   .C.,     0,      0,    0,   0  ] -> [     0,   0,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref3
  [   .C.,     0,      0,    0,   0  ] -> [     0,   0,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref4
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref5
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       1, .X., .X.,  .X., .X., .X. ]; "Ref6
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0, .X., .X.,  .X., .X., .X. ]; "Ref7
  [   .C.,     0,      0,    0,   0  ] -> [     1,   1,       1,      0,      0,     0,       0,   0,   0,    0,   0,   0 ]; "Idle


END DRAM
