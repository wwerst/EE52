MODULE DRAM

TITLE 'DRAM Interface - State Machine Version'

" LCDInterface  DEVICE  'GAL16V8'


" Description:  Interfaces the Hitachi LCD controller with the 80C188
"               microprocessor running at any speed using either the WR\ line,
"               an address line, or the DT/R line as the R/W line for the
"               controller.  SRDY is also generated appropriately.
"
"               If the 80C188 oscillator input frequency is under 17 MHz, the
"               WR\ line may be used as the R/W line.  At higher speeds, an
"               address line or the DT/R line (inverted) must be used.
"
"               At 80C188 oscillator input frequencies of 18.8 MHz or less,
"               one wait state may be removed from the PAL logic.
"
"               The 80C188 should also have 1-2 wait states set on the PCS
"               line for the LCD PAL.


" Revision History:
" 04/18/01   Created from 4/18/01 version of lcdintfs.pds
" 04/16/02   Updated comments
" 04/18/03   Updated comments
" 04/12/06   Updated comments



" Pins


"      pin   1                   input   unused
"      pin   2                   input   unused
"      pin   3                   input   unused
"      pin   4                   input   unused
"      pin   5                   input   unused
"      pin   6                   input   unused
"      pin   7                   input   unused
"      pin   8                   input   unused
"      pin   9                   input   unused
"      pin   10                  input   unused
"      pin   11                  input   unused
"      pin   12                  input   unused
"      pin   13                  input   unused
"      pin   14                  input   unused
"      pin   15                  input   unused
Reset  pin   16;                "input   unused
"      pin   17                  input   unused
RAS    pin   18  ISTYPE 'com';  "input   unused
CAS    pin   19  ISTYPE 'com';  "input   unused
DRAM_WE pin  20  ISTYPE 'com';  "input   unused
R_A_EN pin   21  ISTYPE 'com';  "input   unused
C_A_EN pin   22  ISTYPE 'com';  "input   unused
"      pin   23                  input   unused
"      pin   24                  input   unused
CS     pin   25;                "input chip select
WE     pin   26;                "input for whether write access
!NWAIT pin   27  ISTYPE 'com';  "output for making cpu wait for refresh finish
MCLK   pin   28;                "main clock input
RCLK   pin   29;                "refresh clock input
"      pin   13                  output  unused
"      pin   14                  output  unused
"      pin   15                  output  unused
"      pin   16                  output  unused
St0    pin       ISTYPE 'reg';  "output  state bit 0
St1    pin       ISTYPE 'reg';  "output  state bit 1
St2    pin       ISTYPE 'reg';  "output  state bit 2
St3    pin       ISTYPE 'reg';  "output  state bit 3
St4    pin       ISTYPE 'reg';  "output  state bit 4
"      pin   17                  output  unused
"      pin   18                  output  unused



"the states

StateBits   =  [ St4, St3, St2, St1, St0 ];     " state bits
                                      		" state assignments
Idle        =  [   0,   0,   0,   0,   0 ];     " idle state (waiting for a cycle to start)
Read0       =  [   0,   0,   0,   0,   1 ];     " enable row address for read
Read1       =  [   0,   0,   0,   1,   0 ];     " RAS line low
Read2       =  [   0,   0,   0,   1,   1 ];     " disable row address for read
Read3       =  [   0,   0,   1,   0,   0 ];     " enable column address for read
Read4       =  [   0,   0,   1,   0,   1 ];     " CAS line low
Read5       =  [   0,   0,   1,   1,   0 ];     " Wait for data access
Read6       =  [   0,   0,   1,   1,   1 ];     " CAS line high
Read7       =  [   0,   1,   0,   0,   0 ];     " Pre-charge
Read8       =  [   0,   1,   0,   0,   1 ];     " Pre-charge
Write0      =  [   0,   1,   0,   1,   0 ];     " enable row address
Write1      =  [   0,   1,   0,   1,   1 ];     " RAS line low
Write2      =  [   0,   1,   1,   0,   0 ];     " disable row address
Write3      =  [   0,   1,   1,   0,   1 ];     " WE low and column address enable
Write4      =  [   0,   1,   1,   1,   0 ];     " CAS line low
Write5      =  [   0,   1,   1,   1,   1 ];     " Wait
Write6      =  [   1,   0,   0,   0,   0 ];     " RAS, CAS, WE high
Write7      =  [   1,   0,   0,   0,   1 ];     " Pre-charge
Write8      =  [   1,   0,   0,   1,   0 ];     " Pre-charge
Ref0        =  [   1,   0,   0,   1,   1 ];     " CAS low
Ref1        =  [   1,   0,   1,   0,   0 ];     " RAS low
Ref2        =  [   1,   0,   1,   0,   1 ];     " Wait
Ref3        =  [   1,   0,   1,   1,   0 ];     " Wait
Ref4        =  [   1,   0,   1,   1,   1 ];     " Wait
Ref5        =  [   1,   1,   0,   0,   0 ];     " RAS, CAS high
Ref6        =  [   1,   1,   0,   0,   1 ];     " Pre-charge
Ref7        =  [   1,   1,   0,   1,   0 ];     " Pre-charge

EQUATIONS


" Output enables - enable the used outputs (registered outputs enabled by OE\ pin)


" NWAIT equation
NWAIT      =  !CS & (StateBits == Ref0 # StateBits == Ref1 # StateBits == Ref2 # StateBits == Ref3 # StateBits == Ref4 # StateBits == Ref5 # StateBits == Ref6 # StateBits == Ref7);

" clocks for the registered outputs (state bits)
StateBits.CLK  =  MCLK;        " use the global clock pin



STATE_DIAGRAM  StateBits        " a Mealy state machine


STATE  Idle:                    " in the idle state waiting for an access

   RAS = 1;
   CAS = 1;
   DRAM_WE = 1;
   R_A_EN = 0;
   C_A_EN = 0;

   IF (!CS) THEN  Ref0;     " LCD access starts the cycle
   ELSE IF (CS & WE) THEN Write0;
   ELSE IF (CS) THEN      Read0;
   ELSE                       Idle;     " otherwise just stay here

STATE Read0:

   R_A_EN = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Read1;

STATE Read1:

   RAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Read2;

STATE Read2:

   R_A_EN = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Read3;

STATE Read3:

   C_A_EN = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Read4;

STATE Read4:

   CAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Read5;

STATE Read5:

   IF (Reset) THEN        Idle;
   ELSE                   Read6;


STATE Read6:

   CAS = 1;
   RAS = 1;
   C_A_EN = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Read7;

STATE Read7:


   IF (Reset) THEN        Idle;
   ELSE                   Read8;


STATE Read8:

   GOTO Idle;


STATE Write0:

   R_A_EN = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Write1;

STATE Write1:

   RAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Write2;

STATE Write2:

   R_A_EN = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Write3;

STATE Write3:

   DRAM_WE = 0;
   C_A_EN = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Write4;

STATE Write4:

   CAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Write5;

STATE Write5:

   IF (Reset) THEN        Idle;
   ELSE                   Write6;


STATE Write6:

   CAS = 1;
   RAS = 1;
   C_A_EN = 0;
   DRAM_WE = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Write7;

STATE Write7:


   IF (Reset) THEN        Idle;
   ELSE                   Write8;


STATE Write8:

   GOTO Idle;

STATE Ref0:

   CAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Ref1;

STATE Ref1:

   RAS = 0;

   IF (Reset) THEN        Idle;
   ELSE                   Ref2;


STATE Ref2:


   IF (Reset) THEN        Idle;
   ELSE                   Ref3;

STATE Ref3:


   IF (Reset) THEN        Idle;
   ELSE                   Ref4;


STATE Ref4:


   IF (Reset) THEN        Idle;
   ELSE                   Ref5;


STATE Ref5:

   RAS = 1;
   CAS = 1;

   IF (Reset) THEN        Idle;
   ELSE                   Ref6;

STATE Ref6:

   IF (Reset) THEN        Idle;
   ELSE                   Ref7;

STATE Ref7:


   GOTO                   Idle;


TEST_VECTORS

( [  MCLK,  RCLK, Reset,  CS,  WE  ] -> [   RAS, CAS, DRAM_WE, R_A_EN, C_A_EN, NWAIT, St0,  St1, St2, St3, St4 ] )

  [     0,     0,     0,   0,   0  ] -> [   .X., .X.,     .X.,    .X.,    .X.,   .X., .X., .X.,  .X., .X., .X.];


" reset the system
  [   .C.,     0,     1,   0,   0  ] -> [     1,   1,       1,      0,      0,   .X., .X., .X.,  .X., .X., .X.];

   


END DRAM
